(()=>{"use strict";var e={n:t=>{var n=t&&t.__esModule?()=>t.default:()=>t;return e.d(n,{a:n}),n},d:(t,n)=>{for(var o in n)e.o(n,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:n[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};const t=require("fs");var n=e.n(t);const o=require("os");var r=e.n(o);const s=require("child_process"),c=require("path");var i=e.n(c);const l=require("redis"),a=require("sharp");var u=e.n(a);const g=class{length;rgb;colors;abgr;fl;constructor(e){this.length=e.length,this.rgb=new Uint8Array(3*this.length),this.colors=new Array(this.length),this.abgr=new Uint32Array(this.length),this.fl=new Array(this.length);let t=0;for(let n=0;n<e.length;n++){const o=e[n][0],r=e[n][1],s=e[n][2];this.rgb[t++]=o,this.rgb[t++]=r,this.rgb[t++]=s,this.colors[n]=`rgb(${o}, ${r}, ${s})`,this.abgr[n]=4278190080|s<<16|r<<8|o,this.fl[n]=[o/256,r/256,s/256]}}isDark(e){return e*=3,.2126*this.rgb[e++]+.7152*this.rgb[e++]+.0722*this.rgb[e]<128}getIndexOfColor(e,t,n){const{rgb:o}=this;let r=o.length/3;for(;r>0;){r-=1;const s=3*r;if(o[s]===e&&o[s+1]===t&&o[s+2]===n)return r}return null}getClosestIndexOfColor(e,t,n){const{rgb:o}=this;let r=o.length/3,s=0,c=null;for(;r>0;){r-=1;const i=3*r;let l=(o[i]-e)**2;l+=(o[i+1]-t)**2,l+=(o[i+2]-n)**2,(null===c||c>l)&&(s=r,c=l)}return s}},h=256;function f(e,t){const n=h**2,o=Math.min(t.length,n),r=new Uint8Array(3*n),{rgb:s}=e;let c,i=0;for(let e=0;e<o;e++)c=3*(63&t[e]),r[i++]=s[c++],r[i++]=s[c++],r[i++]=s[c];if(o<n){const e=s[0],t=s[1],c=s[2];for(let s=o;s<n;s+=1)r[i++]=e,r[i++]=t,r[i++]=c}return r}const d=JSON.parse((0,t.readFileSync)(i().resolve(__dirname,"./canvases.json")));console.log("Setting priority for the current process to 15");try{r().setPriority(15)}catch(e){console.log(`: error occurred${e}`)}const[$,y,p,m,k]=process.argv.slice(2);$&&y&&p||(console.error("Usage: node backup.js original_canvas backup_canvas backup_directory"),process.exit(1));const w=(0,l.createClient)($.startsWith("redis://")?{url:$}:{socket:{path:$}}),b=(0,l.createClient)(y.startsWith("redis://")?{url:y}:{socket:{path:y}});function C(){const e=i().resolve(__dirname,p);if(!n().existsSync(e)){console.info(`Backup directory ${p} does not exist! Trying to create it`);try{n().mkdirSync(e)}catch{console.error("Couldn't create backup dir"),process.exit(1)}}const t=new Date;let o=t.getUTCMonth()+1,r=t.getUTCDate();return o<10&&(o=`0${o}`),r<10&&(r=`0${r}`),`${e}/${t.getUTCFullYear()}/${o}/${r}`}async function S(){const e=C();n().existsSync(e)?await async function(){const e=C();n().existsSync(e)||n().mkdirSync(e,{recursive:!0});try{await async function(e,t,o,r){const s=Object.keys(o);for(let c=0;c<s.length;c+=1){const i=s[c],a=o[i];if(a.v||a.hid||a.ed)continue;const f=`${r}/${i}`;n().existsSync(f)||n().mkdirSync(f);const d=new Date;let $=d.getUTCHours(),y=d.getUTCMinutes();$<10&&($=`0${$}`),y<10&&(y=`0${y}`);const p=`${f}/${$}${y}`;console.log(`Using folder ${p}`),n().existsSync(p)||n().mkdirSync(p);const m=new g(a.colors),k=a.size/h;console.log("Creating Incremental Backup...");const w=Date.now();let b=0;for(let o=0;o<k;o++){const r=`${p}/${o}`;let s=!1;for(let c=0;c<k;c++){const a=`ch:${i}:${o}:${c}`;let g=null;try{g=await e.get((0,l.commandOptions)({returnBuffers:!0}),a)}catch(e){console.error(new Error(`Could not get chunk ${a} from redis: ${e.message}`))}let f=null;try{f=await t.get((0,l.commandOptions)({returnBuffers:!0}),a)}catch(e){console.error(new Error(`Could not get chunk ${a} from backup-redis: ${e.message}`))}let d=null;try{if(!f&&!g)continue;f||(f=Buffer.allocUnsafe(0)),g||(g=Buffer.allocUnsafe(0));const{abgr:e}=m,t=f.length,n=g.length;t!==n&&(d=new Uint32Array(h**2));const o=Math.min(t,n);for(let t=0;t<o;t+=1){const n=g[t];f[t]!==n&&(d||(d=new Uint32Array(h**2)),d[t]=e[63&n])}if(!d)continue;for(let o=t;o<n;o+=1)d[o]=e[63&g[o]];if(t>n){const o=e[0];for(let e=n;e<t;e+=1)0!==f[e]&&(d[e]=o)}}catch(e){console.error(new Error(`Could not populate incremental backup data of chunk ${a}: ${e.message}`));continue}try{s||n().existsSync(r)||(s=!0,n().mkdirSync(r));const e=`${r}/${c}.png`;await u()(Buffer.from(d.buffer),{raw:{width:h,height:h,channels:4}}).toFile(e),b+=1}catch(e){console.error(new Error(`Could not save incremental backup of chunk ${a}: ${e.message}`))}}}const C=Date.now()-w;console.log(`Finished Incremental backup of ${b} chunks in ${C}ms.`)}}(w,b,d,e)}catch(e){console.log("Error occurred during incremental backup",e)}}():await async function(){const e=C();n().existsSync(e)||n().mkdirSync(e,{recursive:!0}),await b.flushAll("ASYNC");try{await async function(e,t,n){const o=Object.keys(n);for(let r=0;r<o.length;r+=1){const s=o[r],c=n[s];if(c.v||c.hid||c.ed)continue;const i=c.size/h;console.log("Copy Chunks to backup redis...");const a=Date.now();let u=0;for(let n=0;n<i;n++)for(let o=0;o<i;o++){const r=`ch:${s}:${n}:${o}`;let c=null;try{c=await e.get((0,l.commandOptions)({returnBuffers:!0}),r)}catch(e){console.error(new Error(`Could not get chunk ${r} from redis: ${e.message}`))}if(c)try{await t.set(r,c),u+=1}catch(e){console.error(new Error(`Could not create chunk ${r} in backup-redis: ${e.message}`))}}const g=Date.now()-a;console.log(`Finished Copying ${u} chunks in ${g}ms.`)}}(w,b,d),await async function(e,t,o){const r=Object.keys(t);for(let s=0;s<r.length;s+=1){const c=r[s],i=`${o}/${c}`;n().existsSync(i)||n().mkdirSync(i);const a=`${i}/tiles`;n().existsSync(a)||n().mkdirSync(a);const d=t[c],$=new g(d.colors),y=d.size/h;console.log("Create PNG tiles from backup...");const p=Date.now();let m=0;for(let t=0;t<y;t++){const o=`${a}/${t}`;n().existsSync(o)||n().mkdirSync(o);for(let n=0;n<y;n++){const r=`ch:${c}:${t}:${n}`;let s=null;try{s=await e.get((0,l.commandOptions)({returnBuffers:!0}),r)}catch(e){console.error(new Error(`Could not get chunk ${r} from redis: ${e.message}`))}if(s&&s.length){try{const e=f($,s),t=`${o}/${n}.png`;await u()(Buffer.from(e.buffer),{raw:{width:h,height:h,channels:3}}).toFile(t)}catch(e){console.error(new Error(`Could not save daily backup of chunk ${r}: ${e.message}`));continue}m+=1}}}const k=Date.now()-p;console.log(`Finished creating PNG backup of ${m} chunks in ${k}ms.`)}}(b,d,e)}catch(t){n().rmSync(e,{recursive:!0}),console.log("Error occurred during daily backup",t)}console.log("Daily full backup done")}(),k&&function(e){const t=Date.now();console.log(`Executing ${e}`);const n=(0,s.spawn)(e);n.on("exit",(n=>{0!==n&&console.log(`${e} failed with code ${n}`);const o=Date.now()-t;console.log(`${e} done in ${o}ms`)})),n.stdout.on("data",(t=>{console.log(`${e}: ${t}`)})),n.stderr.on("data",(t=>{console.log(`${e} error: ${t}`)}))}(k),m||process.exit(0),console.log(`Creating next backup in ${m} minutes`),setTimeout(S,60*m*1e3)}w.on("error",(()=>{console.error("Could not connect to canvas redis"),process.exit(1)})),b.on("error",(()=>{console.error("Could not connect to backup redis"),process.exit(1)})),console.log("Starting backup..."),w.connect().then((()=>b.connect())).then((()=>S()))})();
"use strict";(self.webpackChunkpixelplanet=self.webpackChunkpixelplanet||[]).push([[882],{156:(e,t,n)=>{n.r(t),n.d(t,{default:()=>R});var o=n(9477);class s extends o.Mesh{static isSky=!0;constructor(){const e=s.SkyShader,t=new o.ShaderMaterial({name:"SkyShader",fragmentShader:e.fragmentShader,vertexShader:e.vertexShader,uniforms:o.UniformsUtils.clone(e.uniforms),side:o.BackSide,depthWrite:!1});super(new o.BoxGeometry(1,1,1),t)}}s.SkyShader={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new o.Vector3},up:{value:new o.Vector3(0,1,0)}},vertexShader:"\n  uniform vec3 sunPosition;\n  uniform float rayleigh;\n  uniform float turbidity;\n  uniform float mieCoefficient;\n  uniform vec3 up;\n\n  varying vec3 vWorldPosition;\n  varying vec3 vSunDirection;\n  varying float vSunfade;\n  varying vec3 vBetaR;\n  varying vec3 vBetaM;\n  varying float vSunE;\n\n  // constants for atmospheric scattering\n  const float e = 2.71828182845904523536028747135266249775724709369995957;\n  const float pi = 3.141592653589793238462643383279502884197169;\n\n  // wavelength of used primaries, according to preetham\n  const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n  // this pre-calculation replaces older TotalRayleigh(vec3 lambda) function:\n  // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n  const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n  // mie stuff\n  // K coefficient for the primaries\n  const float v = 4.0;\n  const vec3 K = vec3( 0.686, 0.678, 0.666 );\n  // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n  const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n  // earth shadow hack\n  // cutoffAngle = pi / 1.95;\n  const float cutoffAngle = 1.6110731556870734;\n  const float steepness = 1.5;\n  const float EE = 1000.0;\n\n  float sunIntensity( float zenithAngleCos ) {\n    zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n    return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n  }\n\n  vec3 totalMie( float T ) {\n    float c = ( 0.2 * T ) * 10E-18;\n    return 0.434 * c * MieConst;\n  }\n\n  void main() {\n\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    gl_Position.z = gl_Position.w; // set z to camera.far\n\n    vSunDirection = normalize( sunPosition );\n\n    vSunE = sunIntensity( dot( vSunDirection, up ) );\n\n    vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n    float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n    // extinction (absorption + out scattering)\n    // rayleigh coefficients\n    vBetaR = totalRayleigh * rayleighCoefficient;\n\n    // mie coefficients\n    vBetaM = totalMie( turbidity ) * mieCoefficient;\n\n  }",fragmentShader:"\n  varying vec3 vWorldPosition;\n  varying vec3 vSunDirection;\n  varying float vSunfade;\n  varying vec3 vBetaR;\n  varying vec3 vBetaM;\n  varying float vSunE;\n\n  uniform float mieDirectionalG;\n  uniform vec3 up;\n\n  const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n  // constants for atmospheric scattering\n  const float pi = 3.141592653589793238462643383279502884197169;\n\n  const float n = 1.0003; // refractive index of air\n  const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n  // optical length at zenith for molecules\n  const float rayleighZenithLength = 8.4E3;\n  const float mieZenithLength = 1.25E3;\n  // 66 arc seconds -> degrees, and the cosine of that\n  const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n  // 3.0 / ( 16.0 * pi )\n  const float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n  // 1.0 / ( 4.0 * pi )\n  const float ONE_OVER_FOURPI = 0.07957747154594767;\n\n  float rayleighPhase( float cosTheta ) {\n    return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n  }\n\n  float hgPhase( float cosTheta, float g ) {\n    float g2 = pow( g, 2.0 );\n    float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n    return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n  }\n\n  void main() {\n\n    vec3 direction = normalize( vWorldPosition - cameraPos );\n\n    // optical length\n    // cutoff angle at 90 to avoid singularity in next formula.\n    float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n    float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n    float sR = rayleighZenithLength * inverse;\n    float sM = mieZenithLength * inverse;\n\n    // combined extinction factor\n    vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n    // in scattering\n    float cosTheta = dot( direction, vSunDirection );\n\n    float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n    vec3 betaRTheta = vBetaR * rPhase;\n\n    float mPhase = hgPhase( cosTheta, mieDirectionalG );\n    vec3 betaMTheta = vBetaM * mPhase;\n\n    vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n    Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n    // nightsky\n    float theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n    float phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n    vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n    vec3 L0 = vec3( 0.1 ) * Fex;\n\n    // composition + solar disc\n    float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n    L0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n    vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n    vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n    gl_FragColor = vec4( retColor, 1.0 );\n\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n\n  }"};class a extends o.Mesh{constructor(e,t,n,s){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"xzy";n=n||new o.Color("white"),e=e||10,t=t||100,s=s||8e3;const i=a.substring(0,2);super(new o.PlaneBufferGeometry(2,2,1,1),new o.ShaderMaterial({side:o.DoubleSide,uniforms:{uSize1:{value:e},uSize2:{value:t},uColor:{value:n},uDistance:{value:s}},transparent:!0,vertexShader:`\n         varying vec3 worldPosition;\n         uniform float uDistance;\n         void main() {\n              vec3 pos = position.${a} * uDistance;\n              pos.${i} += cameraPosition.${i};\n\n              worldPosition = pos;\n\n              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n         }\n         `,fragmentShader:`\n         varying vec3 worldPosition;\n\n         uniform float uSize1;\n         uniform float uSize2;\n         uniform vec3 uColor;\n         uniform float uDistance;\n\n          float getGrid(float size) {\n              vec2 r = worldPosition.${i} / size;\n\n              vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n              float line = min(grid.x, grid.y);\n\n              return 1.0 - min(line, 1.0);\n          }\n\n         void main() {\n                float d = 1.0 - min(distance(cameraPosition.${i}, worldPosition.${i}) / uDistance, 1.0);\n\n                float g1 = getGrid(uSize1);\n                float g2 = getGrid(uSize2);\n\n\n                gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, 3.0));\n                gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2);\n\n                if ( gl_FragColor.a <= 0.0 ) discard;\n\n\n         }\n\n         `,extensions:{derivatives:!0}})),this.frustumCulled=!1}}var i=n(940),r=n(259),h=n(403);const c=i.wL/2,l={LEFT:o.MOUSE.ROTATE,MIDDLE:o.MOUSE.DOLLY,RIGHT:o.MOUSE.PAN},u=o.TOUCH.ROTATE,d=o.TOUCH.DOLLY_PAN,f=-1,p=Math.PI,m=class{store;camera;renderer;domElement;state;target;spherical=new o.Spherical;sphericalDelta=new o.Spherical;scale=1;panOffset=new o.Vector3;rotateStart=new o.Vector2;rotateEnd=new o.Vector2;rotateDelta=new o.Vector2;panStart=new o.Vector2;panEnd=new o.Vector2;panDelta=new o.Vector2;dollyStart=new o.Vector2;dollyEnd=new o.Vector2;dollyDelta=new o.Vector2;v=new o.Vector3;quat;quatInverse;storeViewInStateTime=Date.now();prevTime=Date.now();offset=new o.Vector3;velocity=new o.Vector3;vec=new o.Vector3;forceNextUpdate=!1;clickTapStartTime=0;wasEverMultiTap=!1;clickTapStartCoords=[0,0];tapTimeout=null;constructor(e,t,n,s,a){this.renderer=e,this.camera=t,this.domElement=s,this.store=a,this.target=n,this.state=f,this.onContextMenu=this.onContextMenu.bind(this),this.onMouseDown=this.onMouseDown.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onMouseWheel=this.onMouseWheel.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onTouchEnd=this.onTouchEnd.bind(this),this.onTouchMove=this.onTouchMove.bind(this),this.domElement.addEventListener("contextmenu",this.onContextMenu,!1),this.domElement.addEventListener("mousedown",this.onMouseDown,!1),this.domElement.addEventListener("wheel",this.onMouseWheel,!1),this.domElement.addEventListener("touchstart",this.onTouchStart,!1),this.domElement.addEventListener("touchend",this.onTouchEnd,!1),this.domElement.addEventListener("touchmove",this.onTouchMove,!1),-1===this.domElement.tabIndex&&(this.domElement.tabIndex=0),this.quat=(new o.Quaternion).setFromUnitVectors(t.up,new o.Vector3(0,1,0)),this.quatInverse=this.quat.clone().invert()}dispose(){const{domElement:e}=this;e.removeEventListener("contextmenu",this.onContextMenu,!1),e.removeEventListener("mousedown",this.onMouseDown,!1),e.removeEventListener("wheel",this.onMouseWheel,!1),e.removeEventListener("touchstart",this.onTouchStart,!1),e.removeEventListener("touchend",this.onTouchEnd,!1),e.removeEventListener("touchmove",this.onTouchMove,!1),document.removeEventListener("mousemove",this.onMouseMove,!1),document.removeEventListener("mouseup",this.onMouseUp,!1)}rotateLeft(e){this.sphericalDelta.theta-=e}rotateUp(e){this.sphericalDelta.phi-=e}pan(e,t){const{camera:n,domElement:o,v:s}=this,{position:a,matrix:i}=n;s.copy(a).sub(this.target);let r=s.length();r*=Math.tan(n.fov/2*Math.PI/180);let h=2*e*r/o.clientHeight;s.setFromMatrixColumn(i,0),s.multiplyScalar(-h),this.panOffset.add(s),h=2*t*r/o.clientHeight,s.setFromMatrixColumn(i,1),s.multiplyScalar(h),this.panOffset.add(s)}handleMouseDownRotate(e){this.rotateStart.set(e.clientX,e.clientY)}handleMouseDownDolly(e){this.dollyStart.set(e.clientX,e.clientY)}handleMouseDownPan(e){this.panStart.set(e.clientX,e.clientY)}handleMouseMoveRotate(e){const{rotateStart:t,rotateEnd:n,rotateDelta:o,domElement:s}=this;n.set(e.clientX,e.clientY),this.rotateDelta.subVectors(n,t).multiplyScalar(1),this.rotateLeft(Math.PI*o.x/s.clientHeight),this.rotateUp(Math.PI*o.y/s.clientHeight),this.rotateStart.copy(n)}handleMouseMoveDolly(e){const{dollyStart:t,dollyEnd:n,dollyDelta:o}=this;n.set(e.clientX,e.clientY),o.subVectors(n,t),o.y>0?this.scale/=.95:o.y<0&&(this.scale*=.95),t.copy(this.dollyEnd)}handleMouseMovePan(e){const{panStart:t,panEnd:n,panDelta:o}=this;n.set(e.clientX,e.clientY),o.subVectors(n,t).multiplyScalar(1),this.pan(o.x,o.y),t.copy(n)}handleMouseWheel(e){e.deltaY<0?this.scale*=.95:e.deltaY>0&&(this.scale/=.95),this.forceNextUpdate=!0}handleTouchStartRotate(e){if(1===e.touches.length)this.rotateStart.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);this.rotateStart.set(t,n)}}handleTouchStartPan(e){if(1===e.touches.length)this.panStart.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);this.panStart.set(t,n)}}handleTouchStartDolly(e){const t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,o=Math.sqrt(t*t+n*n);this.dollyStart.set(0,o)}handleTouchStartDollyPan(e){this.handleTouchStartDolly(e),this.handleTouchStartPan(e)}handleTouchStartDollyRotate(e){this.handleTouchStartDolly(e),this.handleTouchStartRotate(e)}handleTouchMoveRotate(e){const{rotateStart:t,rotateEnd:n,rotateDelta:o,domElement:s}=this;if(1===e.touches.length)n.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),o=.5*(e.touches[0].pageY+e.touches[1].pageY);n.set(t,o)}o.subVectors(n,t).multiplyScalar(1),this.rotateLeft(2*Math.PI*o.x/s.clientHeight),this.rotateUp(2*Math.PI*o.y/s.clientHeight),t.copy(n)}handleTouchMovePan(e){const{panStart:t,panEnd:n,panDelta:o}=this;if(1===e.touches.length)n.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),o=.5*(e.touches[0].pageY+e.touches[1].pageY);n.set(t,o)}o.subVectors(n,t).multiplyScalar(1),this.pan(o.x,o.y),t.copy(n)}handleTouchMoveDolly(e){const{dollyStart:t,dollyEnd:n,dollyDelta:o}=this,s=e.touches[0].pageX-e.touches[1].pageX,a=e.touches[0].pageY-e.touches[1].pageY,i=Math.sqrt(s*s+a*a);n.set(0,i),o.set(0,(n.y/t.y)**1),this.scale/=o.y,t.copy(n)}handleTouchMoveDollyPan(e){this.handleTouchMoveDolly(e),this.handleTouchMovePan(e)}handleTouchMoveDollyRotate(e){this.handleTouchMoveDolly(e),this.handleTouchMoveRotate(e)}placeVoxelOnScreen(e,t){const n=this.renderer.castRay(e);if(!n)return;const o=n.point.clone().add(n.face.normal.multiplyScalar(.5)).floor().addScalar(.5).floor();if(o.clone().sub(this.camera.position).length()<t){const[e,t,n]=o.toArray();this.renderer.placeVoxel(e,t,n)}}deleteVoxelOnScreen(e,t){const n=this.renderer.castRay(e);if(!n)return;const o=n.point.clone().add(n.face.normal.multiplyScalar(-.5)).floor().addScalar(.5).floor();if(!(o.y<0)&&o.clone().sub(this.camera.position).length()<t){const[e,t,n]=o.toArray();this.renderer.placeVoxel(e,t,n,0)}}selectColorOnScreen(e){this.store.dispatch((0,h.Or)(e))}handleMouseUp(e){if(!this.clickTapStartTime||Date.now()-this.clickTapStartTime>300||this.store.getState().fetching.fetchingPixel)return;const t=(0,r.bt)(e);if(!((0,r.ad)(t,this.clickTapStartCoords)>6))switch(e.button){case 0:this.placeVoxelOnScreen(t,120);break;case 1:this.selectColorOnScreen(t);break;case 2:this.deleteVoxelOnScreen(t,120)}}handleTouchEnd(e){if(e.touches.length||!this.clickTapStartTime||Date.now()-this.clickTapStartTime>300||this.store.getState().fetching.fetchingPixel)return;const t=(0,r.bt)(e);(0,r.ad)(t,this.clickTapStartCoords)>6||this.placeVoxelOnScreen(t,90)}onLongTap(e){if(!this.clickTapStartTime||this.store.getState().fetching.fetchingPixel)return;const t=(0,r.bt)(e);(0,r.ad)(t,this.clickTapStartCoords)>6||this.deleteVoxelOnScreen(t,90)}onMouseMove(e){switch(e.preventDefault(),this.state){case 0:this.handleMouseMoveRotate(e);break;case 1:this.handleMouseMoveDolly(e);break;case 2:this.handleMouseMovePan(e)}}onMouseUp(e){this.handleMouseUp(e),this.clickTapStartTime=0,document.removeEventListener("mousemove",this.onMouseMove,!1),document.removeEventListener("mouseup",this.onMouseUp,!1),this.state=f}onMouseWheel(e){this.state!==f&&0!==this.state||(e.preventDefault(),e.stopPropagation(),this.handleMouseWheel(e))}onTouchStart(e){switch(e.preventDefault(),1===e.touches.length?(this.clickTapStartTime=Date.now(),this.clickTapStartCoords=(0,r.bt)(e),this.tapTimeout=setTimeout((()=>{this.onLongTap(e)}),600)):(this.clickTapStartTime=0,clearTimeout(this.tapTimeout)),e.touches.length){case 1:switch(u){case o.TOUCH.ROTATE:this.handleTouchStartRotate(e),this.state=3;break;case o.TOUCH.PAN:this.handleTouchStartPan(e),this.state=4;break;default:this.state=f}break;case 2:switch(d){case o.TOUCH.DOLLY_PAN:this.handleTouchStartDollyPan(e),this.state=5;break;case o.TOUCH.DOLLY_ROTATE:this.handleTouchStartDollyRotate(e),this.state=6;break;default:this.state=f}break;default:this.state=f}}onTouchMove(e){e.preventDefault(),e.stopPropagation();const t=(0,r.bt)(e);switch((0,r.ad)(t,this.clickTapStartCoords)>6&&(clearTimeout(this.tapTimeout),this.clickTapStartTime=0),this.state){case 3:this.handleTouchMoveRotate(e);break;case 4:this.handleTouchMovePan(e);break;case 5:this.handleTouchMoveDollyPan(e);break;case 6:this.handleTouchMoveDollyRotate(e);break;default:this.state=f}}onTouchEnd(e){e.preventDefault(),e.touches.length||(clearTimeout(this.tapTimeout),this.handleTouchEnd(e),this.clickTapStartTime=0),this.state=f}onContextMenu(e){e.preventDefault()}onMouseDown(e){let t;switch(e.preventDefault(),this.clickTapStartTime=Date.now(),this.clickTapStartCoords=(0,r.bt)(e),this.domElement.focus?this.domElement.focus():window.focus(),e.button){case 0:t=l.LEFT;break;case 1:t=l.MIDDLE;break;case 2:t=l.RIGHT;break;default:t=-1}switch(t){case o.MOUSE.DOLLY:this.handleMouseDownDolly(e),this.state=1;break;case o.MOUSE.ROTATE:e.ctrlKey||e.metaKey?(this.handleMouseDownPan(e),this.state=2):(this.handleMouseDownRotate(e),this.state=0);break;case o.MOUSE.PAN:e.ctrlKey||e.metaKey?(this.handleMouseDownRotate(e),this.state=0):(this.handleMouseDownPan(e),this.state=2);break;default:this.state=f}this.state!==f&&(document.addEventListener("mousemove",this.onMouseMove,!1),document.addEventListener("mouseup",this.onMouseUp,!1))}getPolarAngle(){return this.spherical.phi}getAzimuthalAngle(){return this.spherical.theta}update(e){const t=Date.now(),n=this.store.getState(),{moveU:o,moveV:s,moveW:a}=n.gui,r=o||s||a;if(!(e||this.state!==f||this.forceNextUpdate||r))return this.prevTime=t,!1;this.forceNextUpdate=!1;const h=(t-this.prevTime)/1e3;this.prevTime=t;const{camera:l,target:u,velocity:d,offset:m,vec:v,spherical:g,panOffset:S,sphericalDelta:w}=this;r&&(d.set(-o,a,s).normalize().multiplyScalar(1e3*h),v.setFromMatrixColumn(l.matrix,0),v.crossVectors(l.up,v),v.multiplyScalar(-d.z*h),v.y+=-d.y*h,S.add(v),v.setFromMatrixColumn(l.matrix,0),v.multiplyScalar(-d.x*h),S.add(v)),m.copy(l.position).sub(u),m.applyQuaternion(this.quat),g.setFromVector3(m),g.theta+=w.theta,g.phi+=w.phi,g.theta=Math.max(-1/0,Math.min(1/0,g.theta)),g.phi=Math.max(0,Math.min(p,g.phi)),g.makeSafe(),g.radius*=this.scale,g.radius=Math.max(0,Math.min(1/0,g.radius)),S.length()>1e3&&S.set(0,0,0),u.add(S);const y=n.canvas.canvasSize/2;return u.clamp({x:-y,y:0,z:-y},{x:y,y:i.Tj,z:y}),m.setFromSpherical(g),m.applyQuaternion(this.quatInverse),this.camera.position.copy(u).add(m),l.lookAt(u),w.set(0,0,0),S.set(0,0,0),this.scale=1,this.storeViewInStateTime+c<t&&(this.storeViewInStateTime=t,this.renderer.storeViewInState()),!0}};var v=n(785),g=n(686),S=n(802);const w=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],y=[[[0,1,0],[0,0,0],[0,1,1],[0,0,1]],[[1,1,1],[1,0,1],[1,1,0],[1,0,0]],[[1,0,1],[0,0,1],[1,0,0],[0,0,0]],[[0,1,1],[1,1,1],[0,1,0],[1,1,0]],[[1,0,0],[0,0,0],[1,1,0],[0,1,0]],[[0,0,1],[1,0,1],[0,1,1],[1,1,1]]],M=new o.MeshLambertMaterial({vertexColors:!0});class T extends S.Z{key;ready=!1;palette;buffer;mesh=null;faceCnt;lastPixel;heightMap;constructor(e,t,n,o){super(0,n,o),this.recUpdates=!0,this.key=t,this.palette=e}destructor(){this.mesh&&this.mesh.geometry.dispose()}getVoxel(e,t,n){const{buffer:o}=this;if(!o)return 0;if(e<0||e>=i.fS||t>=i.Tj||n<0||n>=i.fS)return 0;if(t<0)return 1;const s=T.getOffsetOfVoxel(e,t,n);return this.buffer[s]}getVoxelByOffset(e){const{buffer:t}=this;return t?t[e]:0}static calculateMetaData(e){const t=i.fS**2,n=new Uint8Array(t);let o=0,s=0,a=0;for(let r=i.fS-1;r>=0;--r)for(let h=i.fS-1;h>=0;--h){let c=0;const l=h+r*i.fS;let u=l;for(let n=0;n<i.Tj;++n)0!==e[u]&&(c=n,0!==h&&0!==e[u-1]||(a+=1),h!==i.fS-1&&0!==e[u+1]||(a+=1),0!==r&&0!==e[u-i.fS]||(a+=1),r!==i.fS-1&&0!==e[u+i.fS]||(a+=1),0!==n&&0===e[u-i.fS**2]&&(a+=1),n!==i.Tj-1&&0!==e[u+i.fS**2]||(a+=1)),u+=t;n[l]=c,c>o&&(o=c,s=T.getOffsetOfVoxel(h,c,r))}return[a,s,n]}static getOffsetOfVoxel(e,t,n){return e+n*i.fS+t*i.fS*i.fS}static getXZOfVoxel(e){const t=e%(i.fS*i.fS),n=(e-t)/(i.fS*i.fS),o=t%i.fS;return[o,n,(t-o)/i.fS]}setVoxelByOffset(e,t){e>this.lastPixel&&(this.lastPixel=e);const n=i.fS**2,o=e%n,s=(e-o)/n;s>this.heightMap[o]&&(this.heightMap[o]=s),this.buffer[e]=t,this.faceCnt+=6,this.renderChunk()}setVoxel(e,t,n,o){const s=T.getOffsetOfVoxel(e,t,n);this.setVoxelByOffset(s,o)}async fromBuffer(e){let t=e;const n=i.fS**2*i.Tj;t.byteLength<n&&(console.log(`Padding chunk ${this.key} with ${n-t.byteLength} voxels to full length`),t=new Uint8Array(n),t.set(e)),this.buffer=t;const[o,s,a]=T.calculateMetaData(t);this.faceCnt=o,this.lastPixel=s,this.heightMap=a,this.renderChunk(),this.ready=!0}empty(){const e=new Uint8Array(i.fS*i.fS*i.Tj),t=new Uint8Array(i.fS*i.fS);this.buffer=e,this.heightMap=t,this.faceCnt=0,this.lastPixel=0,this.renderChunk(),this.ready=!0}calculateGeometryData(){const e=i.fS**2;let t,n=0;const{faceCnt:o}=this,s=new Float32Array(4*o*3),a=new Float32Array(4*o*3),r=new Uint8Array(4*o*3),h=new Uint32Array(6*o),{rgb:c}=this.palette;for(let o=0;o<i.fS;++o)for(let l=0;l<i.fS;++l){const u=l+o*i.fS,d=this.heightMap[u];let f=u;for(let i=0;i<=d;++i){if(t=63&this.buffer[f],0!==t){t*=3;for(let e=0;e<6;++e){const u=w[e],d=y[e];if(0===this.getVoxel(l+u[0],i+u[1],o+u[2])){let e=4*n*3;for(let n=0;n<4;++n){const h=d[n];s[e]=h[0]+l,a[e]=u[0],r[e++]=c[t],s[e]=h[1]+i,a[e]=u[1],r[e++]=c[t+1],s[e]=h[2]+o,a[e]=u[2],r[e++]=c[t+2]}const f=4*n;e=6*n,h[e++]=f,h[e++]=f+1,h[e++]=f+2,h[e++]=f+2,h[e++]=f+1,h[e]=f+3,n+=1}}}f+=e}}return this.faceCnt=n,[s,a,r,h]}renderChunk(){const[e,t,n,s]=this.calculateGeometryData(),a=this.mesh?this.mesh.geometry:new o.BufferGeometry;a.setAttribute("position",new o.BufferAttribute(e,3)),a.setAttribute("normal",new o.BufferAttribute(t,3)),a.setAttribute("color",new o.BufferAttribute(n,3,!0)),a.setIndex(new o.BufferAttribute(s,1)),a.computeBoundingSphere(),a.setDrawRange(0,6*this.faceCnt),this.mesh||(this.mesh=new o.Mesh(a,M),this.mesh.name=this.key)}}const x=T;var b=n(631);class E extends g.Z{palette;constructor(e,t,n,o){super(e,t),this.palette=n,this.canvasSize=o}getVoxel(e,t,n){const{canvasSize:o}=this,[s,a]=(0,r.sG)(o,e,t,n),i=(0,r.NK)(o,e,t,n),h=`${s}:${a}`,c=this.cget(h);return c?c.getVoxelByOffset(i):0}getVoxelUpdate(e,t,n,o){const s=`${e}:${t}`,a=this.cget(s);a&&a.setVoxelByOffset(n,o)}getChunk(e,t,n){const o=`${e}:${t}`;let s=this.cget(o);return s?s.ready?(s.touch(),s.mesh):null:(n&&(s=new x(this.palette,o,e,t),this.cset(o,s),this.fetchChunk(e,t,s)),null)}async fetchChunk(e,t,n){this.bcReqChunk(n);try{const o=`${b.Fx}/chunks/${this.canvasId}/${e}/${t}.bmp`,s=await fetch(o);if(!s.ok)throw new Error("Network response was not ok.");{const e=await s.arrayBuffer();if(!e.byteLength)throw new Error("Chunk response was invalid");{const t=new Uint8Array(e);n.fromBuffer(t)}this.bcRecChunk(n)}}catch(e){n.empty(),this.bcReqChunkFail(n,e)}}}const D=E;var C=n(906);const k=150;class P extends v.Z{scene;camera;centerChunk=[null,null];target=new o.Vector3;rollOverMesh;objects=[];loadedChunks=new Map;plane;oobGeometry;oobMaterial;threeRenderer;mouse=new o.Vector2;raycaster=new o.Raycaster;lastIntersect=0;constructor(e){super(e),this.is3D=!0;const t=e.getState(),n=new o.PerspectiveCamera(45,window.innerWidth/window.innerHeight,5,600);this.camera=n,n.position.set(0,150,190),n.lookAt(this.target),this.loadViewFromState();const r=new o.Scene;this.scene=r;const h=new o.AmbientLight(2236962);r.add(h);const c=new o.DirectionalLight(16777215,1);c.position.set(80,80,75);const l=new o.DirectionalLight(16777215,.4);l.position.set(-80,80,-75),r.add(c),r.add(l);const u=new s;u.scale.setScalar(45e4),r.add(u),r.fog=new o.FogExp2(16777215,.003);const{uniforms:d}=u.material;d.turbidity.value=10,d.rayleigh.value=2,d.mieCoefficient.value=.005,d.mieDirectionalG.value=.8,d.sunPosition.value.set(4e5,4e5,4e5);const f=new o.BoxBufferGeometry(1,1,1),p=new o.MeshBasicMaterial({color:16711680,opacity:.5,transparent:!0});this.rollOverMesh=new o.Mesh(f,p),r.add(this.rollOverMesh);const v=new a(1,10);r.add(v);const g=new o.PlaneBufferGeometry(1024,1024);g.rotateX(-Math.PI/2);const S=new o.Mesh(g,new o.MeshLambertMaterial({color:13296639}));r.add(S),this.plane=S,this.objects.push(S),this.plane.position.y=-.1;const w=new o.PlaneBufferGeometry(i.fS,i.fS);w.rotateX(-Math.PI/2),w.translate(i.fS/2,.2,i.fS/2);const y=new o.MeshLambertMaterial({color:"#C4C4C4"});this.oobGeometry=w,this.oobMaterial=y;const M=new o.WebGLRenderer({preserveDrawingBuffer:!0});M.setPixelRatio(window.devicePixelRatio),M.setSize(window.innerWidth,window.innerHeight);const{domElement:T}=M;T.className="viewport",document.body.appendChild(T),this.threeRenderer=M;const x=new m(this,n,this.target,T,e);this.controls=x,this.onDocumentMouseMove=this.onDocumentMouseMove.bind(this),this.onDocumentTouchMove=this.onDocumentTouchMove.bind(this),this.onWindowResize=this.onWindowResize.bind(this),T.addEventListener("mousemove",this.onDocumentMouseMove,!1),T.addEventListener("touchmove",this.onDocumentTouchMove,!1),window.addEventListener("resize",this.onWindowResize,!1),this.updateCanvasData(t)}get view(){return this.target.toArray()}destructor(){window.removeEventListener("resize",this.onWindowResize,!1),this.controls.dispose(),this.oobGeometry.dispose(),this.oobMaterial.dispose(),delete this.controls,delete this.scene,delete this.camera,delete this.target,delete this.rollOverMesh,delete this.plane,delete this.oobGeometry,delete this.oobMaterial,delete this.mouse,delete this.raycaster,delete this.loadedChunks,delete this.objects;const{domElement:e}=this.threeRenderer;e.remove(),this.threeRenderer.renderLists.dispose(),this.threeRenderer.dispose(),delete this.threeRenderer,super.destructor()}updateView(e){if(3!==e.length)return;const{target:t}=this,n=t.clone();t.set(...e),n.sub(t),this.camera.position.sub(n),this.forceNextRender=!0}getViewport(){return this.threeRenderer.domElement}updateCanvasData(e){const{canvasId:t,view:n}=e.canvas;if(t!==this.canvasId){if(this.canvasId=t,null!==t){this.loadedChunks.length&&(this.loadedChunks.forEach((e=>{this.scene.remove(e)})),this.loadedChunks=new Map),this.chunkLoader&&this.chunkLoader.destructor(),this.objects=[this.plane];const{palette:n,canvasSize:o}=e.canvas;this.chunkLoader=new D(this.store,t,n,o)}this.updateView(n),this.forceNextRender=!0}}renderPixel(e,t,n,o){const{chunkLoader:s}=this;s&&s.getVoxelUpdate(e,t,n,o),this.forceNextSubrender=!0}isChunkInView(e,t,n){const o=`${t}:${n}`;return!!this.loadedChunks.has(o)}reloadChunks(){if(!this.chunkLoader)return;const{canvasSize:e}=this.store.getState().canvas,{scene:t,loadedChunks:n,chunkLoader:s}=this,{x:a,z:h}=this.target,[c,l]=(0,r.sG)(e,a-k,0,h-k),[u,d]=(0,r.sG)(e,a+k,0,h+k),f=e/i.fS,p=[];for(let a=l;a<=d;++a)for(let r=c;r<=u;++r){const h=`${r}:${a}`;if(p.push(h),!n.has(h)){let c=null;c=r<0||a<0||r>=f||a>=f?new o.Mesh(this.oobGeometry,this.oobMaterial):s.getChunk(r,a,!0),c&&(n.set(h,c),c.position.fromArray([r*i.fS-e/2,0,a*i.fS-e/2]),t.add(c))}}const m=[this.plane];n.forEach(((e,o)=>{p.includes(o)?m.push(e):(t.remove(e),n.delete(o))})),this.plane.position.x=a,this.plane.position.z=h,this.objects=m}debug(e){}render(){if(!this.threeRenderer)return;const e=super.render();if(e){const{canvasSize:e}=this.store.getState().canvas,t=this.centerChunk,{x:n,z:o}=this.target,s=(0,r.sG)(e,n,0,o);t&&t[0]===s[0]&&t[1]===s[1]||(this.centerChunk=s,this.forceNextRender=!0)}(this.forceNextRender||this.forceNextSubrender||e)&&(this.forceNextRender&&this.reloadChunks(),this.threeRenderer.render(this.scene,this.camera),this.forceNextRender=!1,this.forceNextSubrender=!1)}onWindowResize(){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.threeRenderer.setSize(window.innerWidth,window.innerHeight),this.forceNextSubrender=!0}updateRollOverMesh(e,t){const n=Date.now();if(this.lastIntersect+25>n)return;this.lastIntersect=n;const{store:o,rollOverMesh:s,raycaster:a,objects:i,mouse:r,camera:c}=this,l=o.getState(),{fetchingPixel:u}=l.fetching;r.set(e,t),a.setFromCamera(r,c);const d=a.intersectObjects(i);if(d.length>0){const e=d[0],t=e.point.clone().add(e.face.normal.multiplyScalar(.5)).floor().addScalar(.5);if(u||t.clone().sub(c.position).length()>120)-10!==s.position.y&&(this.store.dispatch((0,h.BH)()),s.position.y=-10,this.forceNextSubrender=!0);else{const{hover:e}=l.canvas;s.position.copy(t);const n=t.toArray().map((e=>Math.floor(e)));e&&e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]||(this.store.dispatch((0,h.GZ)(n)),this.forceNextSubrender=!0)}}}onDocumentMouseMove(e){this.updateRollOverMesh(e.clientX/window.innerWidth*2-1,-e.clientY/window.innerHeight*2+1)}onDocumentTouchMove(){-10!==this.rollOverMesh.position.y&&(this.store.dispatch((0,h.BH)()),this.rollOverMesh.position.y=-10)}castRay(e){let[t,n]=e;const{mouse:o,camera:s,raycaster:a,objects:i}=this;o.set(t/window.innerWidth*2-1,-n/window.innerHeight*2+1),a.setFromCamera(o,s);const r=a.intersectObjects(i);return r.length>0?r[0]:null}getPointedColor(){const{objects:e,raycaster:t,mouse:n,camera:o}=this;t.setFromCamera(n,o);const s=t.intersectObjects(e);if(s.length<=0)return null;const a=s[0],i=a.point.clone().add(a.face.normal.multiplyScalar(-.5)).floor().addScalar(.5).floor();if(i.y<0)return null;if(i.clone().sub(o.position).length()<120){const e=i.toArray();if(this.chunkLoader){const t=this.chunkLoader.getVoxel(...e);if(t)return t}}return null}placeVoxel(e,t,n){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const{store:s}=this,a=s.getState(),{canvasSize:i,selectedColor:h}=a.canvas,c=null===o?h:o,l=0===c?this.chunkLoader.getVoxel(e,t,n):0,[u,d]=(0,r.sG)(i,e,t,n),f=(0,r.NK)(i,e,t,n);C.Z.tryPlacePixel(u,d,f,c,l)}}const R=P}}]);